<#@ template language="C#" hostspecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="$(SolutionDir)T4Helper/bin/Debug/T4Helper.dll" #>
<#@ import namespace="System.Collections.Generic" #>
<#
	T4Utils.WriteLine = this.WriteLine;
	T4Utils.FileHeader();
#>
using System;
using System.Collections.Generic;
using System.IO;
using Cmune.Util;
using UberStrike.Core.Serialization;
<#
	var metaData = RealtimeAttributeParser.GetRpcInterfaces((IServiceProvider)this.Host, "Uberstrike.Realtime.CommServer");

	List<RpcInterfaceView> allOperationInterfaces = new List<RpcInterfaceView>();
	allOperationInterfaces.AddRange(metaData.ServerOperations);
	allOperationInterfaces.AddRange(metaData.RoomOperations);

	List<RpcInterfaceView> allEvents = new List<RpcInterfaceView>();
	allEvents.AddRange(metaData.ServerEvents);
	allEvents.AddRange(metaData.RoomEvents);
	
#>

namespace UberStrike.Realtime.Client
{
<#	
	foreach(var operation in allOperationInterfaces)
	{
		string clientPeerBaseClassName = "";
		if(!string.IsNullOrEmpty(operation.Interface))
		{
			clientPeerBaseClassName = operation.GetClassPrefix();
		}
#>
    public sealed class <#=operation.GetClassPrefix()#>Operations : IOperationSender
    {
		public event Func<byte, Dictionary<byte, object>, bool, bool> SendOperation;

		private byte _code = 0;

        public <#=operation.GetClassPrefix()#>Operations(byte opCode = 0)
        {
			_code = opCode;
        }

<#
		foreach (var method in operation.NetworkMethods)
    	{
#>
        public void Send<#=method.Name#>(<#=method.ArgPrint()#>)
        {
			using(MemoryStream stream = new MemoryStream())
			{
<#
				for(int i=0; i < method.Arguments.Count; i++)
				{
#>
				UberStrike.Core.Serialization.<#=Serialization.GetProxyName(method.Arguments[i].Key, method.ArgumentKinds[i])#>.Serialize(stream, <#=method.Arguments[i].Value#><#=Serialization.GetSerializeArguments(method.Arguments[i].Key)#>);
<#
				}
#>
				var _data = new Dictionary<byte, object>()
				{
					{ _code, stream.ToArray() }
				};
				if(SendOperation != null) SendOperation(<#=method.MethodId#>, _data, true);
			}
        }

<#
		}
#>
	}

<#
	}
	
	foreach(var e in allEvents)
	{
		if(metaData.ServerEvents.Contains(e))
		{
#>
    public abstract class Base<#=e.GetClassPrefix()#> : BasePeer, IEventDispatcher
    {
		public <#=e.GetClassPrefix()#>Operations Operations { get; private set; }

        protected Base<#=e.GetClassPrefix()#>(int syncFrequency) 
			: base(syncFrequency)
		{ 
			Operations = new <#=e.GetClassPrefix()#>Operations(1);

            AddRoomLogic(this, Operations);
		}
<#
		}
		else
		{
#>
	public abstract class Base<#=e.GetClassPrefix()#> : IRoomLogic
    {
		public <#=e.GetClassPrefix()#>Operations Operations { get; private set; }

        protected Base<#=e.GetClassPrefix()#>() 
		{ 
			Operations = new <#=e.GetClassPrefix()#>Operations();
		}
		
        IOperationSender IRoomLogic.Operations
        {
            get { return Operations; }
        }
<#
		}
#>

		public void OnEvent(byte id, byte[] data)
        {
            switch (id)
			{
<#
		int counter = 0;
		foreach (var method in e.NetworkMethods)
    	{
#>
				case <#=method.MethodId#>: <#=method.Name#>(data); break;
<#
		}
#>
            }
        }
	
<#
		foreach (var method in e.NetworkMethods)
    	{	
#>
		protected abstract void On<#=method.Name#>(<#=method.ArgPrint()#>);

<#
		}

		foreach (var method in e.NetworkMethods)
    	{	
#>
    	private void <#=method.Name#>(byte[] _bytes)
        {
			using(MemoryStream stream = new MemoryStream(_bytes))
			{
<#
			for(int arg=0; arg<method.Arguments.Count; arg++)
			{
#>
        		<#=method.Arguments[arg].Key#> <#=method.Arguments[arg].Value#> = <#=Serialization.GetProxyName(method.Arguments[arg].Key, method.ArgumentKinds[arg])#>.Deserialize(stream<#=Serialization.GetDeserializeArguments(method.Arguments[arg].Key)#>);
<#
			}
#>
            	On<#=method.Name#>(<#=method.NamePrint()#>);
			}
        }
		
<#
		}
#>
	}
	
<#
	}
#>
}